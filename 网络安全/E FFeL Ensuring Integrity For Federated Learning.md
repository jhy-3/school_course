联合学习（FL）使客户能够与服务器合作，训练机器学习模型。为了确保隐私，服务器对来自客户端的更新进行安全聚合。不幸的是，由于更新被掩盖了，这就阻止了对更新的格式良好性（完整性）的验证。因此，旨在毒害模型的畸形更新可以被注入而不被发现。在本文中，我们正式确定了在FL中确保更新隐私和完整性的问题，并提出了一个新的系统，EIFFeL，它能够安全地聚合经过验证的更新。EIFFeL是一个通用的框架，可以强制执行任意的完整性检查，并从聚合中移除畸形的更新，而不违反隐私。我们的实证评估证明了EIFFeL的实用性。例如，在100个客户和10%的中毒情况下，EIFFeL可以训练MNIST分类模型，使其达到与未中毒的联合学习者相同的精度，每次迭代只需2.4秒。



联合学习（FL；[61]）是一种分散数据的学习范式，其中多个客户端与服务器合作，训练一个机器学习（ML）模型。每个客户端计算其本地训练数据的更新，并与服务器共享；服务器将本地更新汇总为全球模型更新。这允许客户在不分享其私人数据的情况下对模型训练做出贡献。然而，本地更新仍然可以揭示客户的私人数据信息[11, 63, 65, 95, 97]。FL通过使用安全聚合来解决这个问题：客户掩盖他们共享的更新，而服务器只能恢复清晰的最终聚合。
FL的一个主要挑战是它容易受到拜占庭式攻击。特别是，恶意客户可以向学习者注入中毒的更新，目的是降低全局模型的准确性[10, 12, 34, 45, 62]，或在模型中植入后门，以便日后利用[5, 26, 90]。即使是一个畸形的更新，也会大大改变训练过的模型[15]。因此，确保更新的合理性，即维护其完整性，对于确保FL的稳健性至关重要。在安全聚合的背景下，这个问题尤其具有挑战性，因为单个更新被掩盖在服务器上，这使得对它们的审计无法进行。
在FL中的这些挑战导致了一个研究问题。一个联合学习者如何在不侵犯客户隐私的情况下有效地验证客户更新的完整性？
我们通过提出验证输入的安全聚合（SAVI）协议来正式解决这个问题。(1)安全地验证每个本地更新的完整性，(2)只聚合格式良好的更新，以及(3)只在透明状态下发布最终的聚合。SAVI协议允许在不观察更新的情况下检查其完整性，从而确保更新的隐私和完整性。
我们通过提出EIFFeL来证明SAVI的可行性：一个实例化SAVI协议的系统，它可以执行任何完整的检查，可以用公共参数的算术电路来表达。这为EIFFeL提供了实现大量现代ML方法的灵活性，这些方法通过在聚合每个客户的更新之前检查其完整性来确保对拜占庭攻击的稳健性[5, 31, 54, 76, 83, 84, 92, 93]。EIFFeL是一个通用的框架，授权联合学习者在 "屏蔽 "的更新上部署他们选择的（多个）任意的完整性检查。
EIFFeL使用秘密共享的非交互式证明（SNIP；[28]），这是一种零知识证明，为客户服务器设置而优化。然而，SNIP需要多个诚实的验证者来检查该证明。EIFFeL通过精心设计其架构和加密组件，将SNIP扩展到恶意威胁模型。此外，我们开发了一套优化方案，将EIFFeL的性能至少提高了2.3倍。我们对EIFFeL的实证评估证明了它在现实世界中的实用性。例如，在有100个客户和10%的中毒率的情况下，EIFFeL可以将MNIST分类模型训练到与没有中毒的联合学习器相同的精度，每次迭代只需2.4𝑠。
2 问题概述
在这一节中，我们将介绍问题的设置，然后是它的威胁分析和我们解决方案的概述。
2.1 问题设置
在FL中，拥有分布式数据的多方共同训练一个全局模型M，而不向对方明确披露其数据。FL有两种类型的行为者。
- 客户。有𝑛客户，其中每个客户C𝑖,𝑖∈[𝑛]，拥有
一个私人数据集，𝐷𝑖。原始数据不被共享，相反，每个客户都在私人数据集𝐷𝑖上计算M的局部更新，如平均梯度。
- 服务器。有一个不受信任的服务器，S，他协调来自不同客户的更新，以训练M。
训练M的来自不同客户的更新。
FL中的一次训练迭代包括以下步骤。
- 广播。服务器将模型M的当前参数广播给所有客户。
- 本地计算。每个客户C𝑖在本地计算一个更新。
𝑢𝑖，对其数据集𝐷𝑖进行更新。
- 聚合。服务器S收集客户端的更新，并将其汇总，U = Í𝑖 ∈[𝑛] 𝑢𝑖。
- 全局模型更新。服务器 S 基于聚合的更新 U 来更新全局模型 M。
在有大量客户的情况下，典型的做法是对一小部分客户进行子抽样，让其参与特定的迭代。我们假设𝑛表示参与每次迭代的客户数量，C表示这些𝑛客户的子集，服务器在迭代开始时公布。


通过www.DeepL.com/Translator（免费版）翻译



输入隐私（客户的目标）。第一个目标是确保所有诚实客户的隐私。
所有诚实客户的隐私。也就是说，除了可以从最终的聚合U中了解到的信息外，任何一方都不能了解到诚实客户𝐶的原始输入（更新）𝑢𝑖的任何信息。
- 输入的完整性（服务器的目标）。服务器S的动机是
确保来自每个客户的个别更新是完整的。具体来说，服务器有一个公共的验证谓词，Valid(-)，它定义了输入（更新）的语法。一个输入（更新）𝑢被认为是有效的，因此，如果Valid(𝑢)=1，则通过完整性检查。例如，任何每个客户的更新检查，如Zeno++ [93]，都可以成为Valid(-)的良好候选者（我们在第7.2节评估了四个最先进的验证谓词）。
我们假设诚实的客户，用C𝐻表示：(1)正确遵守协议，(2)有良好的输入。我们需要第二个条件，因为如果一个诚实的客户的输入没有通过完整性检查（可以在本地验证，因为Valid(-)是公开的），该客户就没有动力参与训练迭代。
2.3 威胁模型
我们考虑一个恶意对手的威胁模型。


通过www.DeepL.com/Translator（免费版）翻译

- 恶意服务器。我们考虑一个恶意服务器，它可以任意地从协议中脱身，以恢复𝑖∈[𝑛]的原始更新𝑢𝑖（详见后面的备注1）。
我们考虑一个恶意服务器，它可以任意地从协议中退出，目的是恢复原始更新𝑢为𝑖 ∈ [𝑛]（更多细节见后面的备注 1）。
- 恶意客户。我们还考虑一组𝑚恶意客户。
C𝑀。恶意客户可以任意地偏离协议，其目的是 (1)向服务器发送畸形的输入，从而影响最终的聚合；(2)无法通过提交格式良好的更新的诚实客户的完整性检查；(3)侵犯诚实客户的隐私，可能是与服务器串通的。
2.4 解决方案概述
之前的工作主要集中在通过安全聚合确保输入隐私，即安全地计算聚合U = ÍC𝑖 ∈C 𝑢𝑖。
在上述问题设置和威胁分析的激励下，我们引入了一种新型的FL协议，称为带有验证输入的安全聚合（SAVI），它可以确保输入隐私和完整性。SAVI协议的目标是只安全地聚集有充分信息的输入。
为了证明SAVI的可行性，我们提出了EIFFeL：一个为任何Valid(-)实例化SAVI协议的系统，该系统可以被表达为具有公共参数的算术电路（图1）。EIFFeL通过使用Shamir的阈值秘密共享方案[75]（第4.1节）确保输入隐私。输入的完整性是通过SNIP和可验证的秘密共享（VSS）来保证的，它验证了秘密共享的正确性（第4.1节）。其关键思想是。
- SNIP需要多个诚实的验证者。EIFFeL通过让客户在服务器的监督下相互充当验证者，在单服务器环境中实现了这一点（在图2b中，验证者被标记为）。
- EIFFeL将SNIP扩展到恶意威胁模型，以说明恶意客户（验证者）的情况。我们的关键观察是，使用阈值秘密共享方案创造了多个客户子集，可以模拟SNIP验证协议。服务器利用这种冗余来稳健地验证证明，并只用已验证的证明来聚合更新（图2c和2d）。
3 带有验证输入的安全聚合
下面，我们提供一个有验证输入的安全聚合（SAVI）协议的正式定义。
定义1. 给定一个公共验证谓词Valid(-)和安全参数𝜅，协议Π(𝑢1, - - ,𝑢𝑛)是一个带验证输入的安全聚合（SAVI）协议，如果。
- 完整性。协议的输出，out，返回一个客户子集 CValid 的集合，这样 CValid 中的所有客户都有良好的输入形式。

(a) EIFFeL由多个客户端组成 (b) 为了检查证明𝜋𝑖，所有C和一个具有公共估值的服务器S，其他客户端C𝑖作为验证者dation谓词Valid(-)，定义在S的监督下，𝐶𝑖分担完整性检查。客户端C𝑖需要其更新𝑢𝑖和证明𝜋𝑖，以提供Valid(𝑢𝑖)=1的证明𝜋𝑖，门槛𝑚+1的Shamir方案。
(第一回合)。并与C𝑖分享它(第二回合)。	(从概念上讲，C𝑖中任何一组𝑚+1的客户都可以模拟SNIP验证协议。服务器使用这种冗余来稳健地验证证明（第3轮）。	(客户端只聚合形式良好的更新份额，并将产生的聚合结果透露给服务器（第4轮）。
图2：EIFFeL的高层次概述。主要观点见2.4节，系统的详细描述见4.4节。

Pr out = UValid ≥ 1 - negl(𝜅) 其中UValid = ∑︁
C𝑖 ∈CValid
对于所有C𝑖∈CValid，我们有 Valid(𝑢𝑖) = 1 𝑢𝑖	
	C⊆C⊆C。 (1)
	𝐻 Valid
- 隐私。对于一组恶意客户C𝑀和一个恶意服务器S，存在一个概率多项式时间(P.P.T.)模拟器Sim(-)，以便：。

